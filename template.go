// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Added as a .go file to avoid embedding issues of the template.

package main

import (
	"strings"
	"text/template"
)

var funcMap = template.FuncMap{
	"trimPrefix": func(str, prefix string) string {
		return strings.TrimPrefix(prefix, str)
	},
	"toLower": strings.ToLower,
}

var generatedTmpl = template.Must(template.New("generated").Funcs(funcMap).Parse(`
// generated by jsonenums {{.Command}}; DO NOT EDIT
// TypePrefix: {{.TypePrefix}}
// ToLowerCase: {{.ToLowerCase}}

package {{.PackageName}}

import (
    "encoding/json"
    "fmt"
)

{{range $typename, $values := .TypesAndValues}}

var (
    _{{$typename}}NameToValue = map[string]{{$typename}} {
		{{if $.ToLowerCase}}
		{{range $values}}"{{. | trimPrefix $.TypePrefix | toLower}}": {{.}},
		{{end}}
		{{else}}
		{{range $values}}"{{. | trimPrefix $.TypePrefix}}": {{.}},
		{{end}}
		{{end}}
	}

    _{{$typename}}ValueToName = map[{{$typename}}]string {
		{{if $.ToLowerCase}}
		{{range $values}}{{.}}: "{{. | trimPrefix $.TypePrefix | toLower}}",
        {{end}}
		{{else}}
		{{range $values}}{{.}}: "{{. | trimPrefix $.TypePrefix}}",
        {{end}}
		{{end}}
    }
)

func init() {
    var v {{$typename}}
    if _, ok := interface{}(v).(fmt.Stringer); ok {
        _{{$typename}}NameToValue = map[string]{{$typename}} {
            {{range $values}}interface{}({{.}}).(fmt.Stringer).String(): {{.}},
            {{end}}
        }
    }
}

// MarshalJSON is generated so {{$typename}} satisfies json.Marshaler.
func (r {{$typename}}) MarshalJSON() ([]byte, error) {
    if s, ok := interface{}(r).(fmt.Stringer); ok {
        return json.Marshal(s.String())
    }
    s, ok := _{{$typename}}ValueToName[r]
    if !ok {
        return nil, fmt.Errorf("invalid {{$typename}}: %d", r)
    }
    return json.Marshal(s)
}

// UnmarshalJSON is generated so {{$typename}} satisfies json.Unmarshaler.
func (r *{{$typename}}) UnmarshalJSON(data []byte) error {
    var s string
    if err := json.Unmarshal(data, &s); err != nil {
        return fmt.Errorf("{{$typename}} should be a string, got %s", data)
    }
    v, ok := _{{$typename}}NameToValue[s]
    if !ok {
        return fmt.Errorf("invalid {{$typename}} %q", s)
    }
    *r = v
    return nil
}

{{end}}
`))
